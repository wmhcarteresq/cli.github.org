<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="https://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="https://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CannotDeserializeTabCompletionResult" xml:space="preserve">
    <value>The tab completion result cannot be properly deserialized because the remote runspace does not contain a TypeTable instance.</value>
  </data>
  <data name="NoAccessToProperties" xml:space="preserve">
    <value>Cannot access properties on a null instance of the type CompletionResult.</value>
  </data>
  <data name="bnotOperatorDescription" xml:space="preserve">
    <value>Bitwise NOT</value>
  </data>
  <data name="notOperatorDescription" xml:space="preserve">
    <value>Logical not. Negates the statement that follows it.</value>
  </data>
  <data name="eqOperatorDescription" xml:space="preserve">
    <value>Equal to - case insensitive. When the left operand is a collection, returns values from the collection that equal the right operand, otherwise returns TRUE if the left operand equals the right operand.</value>
  </data>
  <data name="ieqOperatorDescription" xml:space="preserve">
    <value>Equal to - case insensitive. When the left operand is a collection, returns values from the collection that equal the right operand, otherwise returns TRUE if the left operand equals the right operand.</value>
  </data>
  <data name="ceqOperatorDescription" xml:space="preserve">
    <value>Equal to - case sensitive. When the left operand is a collection, returns values from the collection that equal the right operand, otherwise returns TRUE if the left operand equals the right operand.</value>
  </data>
  <data name="neOperatorDescription" xml:space="preserve">
    <value>Not equal to - case insensitive. When the left operand is a collection, returns values from the collection that do not equal the right operand, otherwise returns TRUE if the left operand does not equal the right operand.</value>
  </data>
  <data name="ineOperatorDescription" xml:space="preserve">
    <value>Not equal to - case insensitive. When the left operand is a collection, returns values from the collection that do not equal the right operand, otherwise returns TRUE if the left operand does not equal the right operand.</value>
  </data>
  <data name="cneOperatorDescription" xml:space="preserve">
    <value>Not equal to - case sensitive. When the left operand is a collection, returns values from the collection that do not equal the right operand, otherwise returns TRUE if the left operand does not equal the right operand.</value>
  </data>
  <data name="geOperatorDescription" xml:space="preserve">
    <value>Greater than or equal to - case insensitive. When the left operand is a collection, returns values from the collection that are greater than or equal to the right operand, otherwise returns TRUE if the left operand is greater than or equal to the right operand.</value>
  </data>
  <data name="igeOperatorDescription" xml:space="preserve">
    <value>Greater than or equal to - case insensitive. When the left operand is a collection, returns values from the collection that are greater than or equal to the right operand, otherwise returns TRUE if the left operand is greater than or equal to the right operand.</value>
  </data>
  <data name="cgeOperatorDescription" xml:space="preserve">
    <value>Greater than or equal to - case sensitive. When the left operand is a collection, returns values from the collection that are greater than or equal to the right operand, otherwise returns TRUE if the left operand is greater than or equal to the right operand.</value>
  </data>
  <data name="gtOperatorDescription" xml:space="preserve">
    <value>Greater than - case insensitive. When the left operand is a collection, returns values from the collection that are greater than the right operand, otherwise returns TRUE if the left operand is greater than the right operand.</value>
  </data>
  <data name="igtOperatorDescription" xml:space="preserve">
    <value>Greater than - case insensitive. When the left operand is a collection, returns values from the collection that are greater than the right operand, otherwise returns TRUE if the left operand is greater than the right operand.</value>
  </data>
  <data name="cgtOperatorDescription" xml:space="preserve">
    <value>Greater than - case sensitive. When the left operand is a collection, returns values from the collection that are greater than the right operand, otherwise returns TRUE if the left operand is greater than the right operand.</value>
  </data>
  <data name="ltOperatorDescription" xml:space="preserve">
    <value>Less than - case insensitive. When the left operand is a collection, returns values from the collection that are less than the right operand, otherwise returns TRUE if the left operand is less than the right operand.</value>
  </data>
  <data name="iltOperatorDescription" xml:space="preserve">
    <value>Less than - case insensitive. When the left operand is a collection, returns values from the collection that are less than the right operand, otherwise returns TRUE if the left operand is less than the right operand.</value>
  </data>
  <data name="cltOperatorDescription" xml:space="preserve">
    <value>Less than - case sensitive. When the left operand is a collection, returns values from the collection that are less than the right operand, otherwise returns TRUE if the left operand is less than the right operand.</value>
  </data>
  <data name="leOperatorDescription" xml:space="preserve">
    <value>Less than or equal to - case insensitive. When the left operand is a collection, returns values from the collection that are less than or equal to the right operand, otherwise returns TRUE if the left operand is less than or equal to the right operand.</value>
  </data>
  <data name="ileOperatorDescription" xml:space="preserve">
    <value>Less than or equal to - case insensitive. When the left operand is a collection, returns values from the collection that are less than or equal to the right operand, otherwise returns TRUE if the left operand is less than or equal to the right operand.</value>
  </data>
  <data name="cleOperatorDescription" xml:space="preserve">
    <value>Less than or equal to - case sensitive. When the left operand is a collection, returns values from the collection that are less than or equal to the right operand, otherwise returns TRUE if the left operand is less than or equal to the right operand.</value>
  </data>
  <data name="likeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case insensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="ilikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case insensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="clikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case sensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="notlikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case insensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="inotlikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case insensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="cnotlikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case sensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="matchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case insensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="imatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case insensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="cmatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case sensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="notmatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case insensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="inotmatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case insensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="cnotmatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case sensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="replaceOperatorDescription" xml:space="preserve">
    <value>Replace operator - case insensitive. Changes the left operand. Example: (dir *.ps1).FullName -replace '.ps1$','.ps1.bak'</value>
  </data>
  <data name="ireplaceOperatorDescription" xml:space="preserve">
    <value>Replace operator - case insensitive. Changes the left operand. Example: (dir *.ps1).FullName -replace '.ps1$','.ps1.bak'</value>
  </data>
  <data name="creplaceOperatorDescription" xml:space="preserve">
    <value>Replace operator - case sensitive. Changes the left operand. Example: (dir *.ps1).FullName -replace '.ps1$','.ps1.bak'</value>
  </data>
  <data name="containsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (right operand) exactly matches at least one of the values in the left operand.</value>
  </data>
  <data name="icontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (right operand) exactly matches at least one of the values in the left operand.</value>
  </data>
  <data name="ccontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE only when the test value (right operand) exactly matches at least one of the values in the left operand.</value>
  </data>
  <data name="notcontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (right operand) exactly matches none of the values in the left operand.</value>
  </data>
  <data name="inotcontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (right operand) exactly matches none of the values in the left operand.</value>
  </data>
  <data name="cnotcontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE when the test value (right operand) exactly matches none of the values in the left operand.</value>
  </data>
  <data name="inOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (left operand) exactly matches at least one of the values in the right operand.</value>
  </data>
  <data name="iinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (left operand) exactly matches at least one of the values in the right operand.</value>
  </data>
  <data name="cinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE when the test value (left operand) exactly matches at least one of the values in the right operand.</value>
  </data>
  <data name="notinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE when the test value (left operand) exactly matches none of the values in the right operand.</value>
  </data>
  <data name="inotinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (left operand) exactly matches none of the values in the right operand.</value>
  </data>
  <data name="cnotinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE when the test value (left operand) exactly matches none of the values in the right operand.</value>
  </data>
  <data name="splitOperatorDescription" xml:space="preserve">
    <value>Split - case insensitive. Split one or more strings into substrings.
-Split &lt;String&gt;

&lt;String&gt; -Split &lt;Delimiter&gt;[,&lt;Max-substrings&gt;[,"&lt;Options&gt;"]]

&lt;String&gt; -Split {&lt;ScriptBlock&gt;} [,&lt;Max-substrings&gt;]</value>
  </data>
  <data name="isplitOperatorDescription" xml:space="preserve">
    <value>Split - case insensitive. Split one or more strings into substrings.
-Split &lt;String&gt;

&lt;String&gt; -Split &lt;Delimiter&gt;[,&lt;Max-substrings&gt;[,"&lt;Options&gt;"]]

&lt;String&gt; -Split {&lt;ScriptBlock&gt;} [,&lt;Max-substrings&gt;]</value>
  </data>
  <data name="csplitOperatorDescription" xml:space="preserve">
    <value>Split - case sensitive. Split one or more strings into substrings.
-Split &lt;String&gt;

&lt;String&gt; -Split &lt;Delimiter&gt;[,&lt;Max-substrings&gt;[,"&lt;Options&gt;"]]

&lt;String&gt; -Split {&lt;ScriptBlock&gt;} [,&lt;Max-substrings&gt;]</value>
  </data>
  <data name="isnotOperatorDescription" xml:space="preserve">
    <value>Returns TRUE when the left operand is not an instance of the specified .NET Framework type (right operand).</value>
  </data>
  <data name="isOperatorDescription" xml:space="preserve">
    <value>Returns TRUE when the left operand is an instance of the specified .NET Framework type (right operand).</value>
  </data>
  <data name="asOperatorDescription" xml:space="preserve">
    <value>Converts the left operand to the specified .NET Framework type (right operand).</value>
  </data>
  <data name="fOperatorDescription" xml:space="preserve">
    <value>Formats strings by using the format method of string objects.</value>
  </data>
  <data name="andOperatorDescription" xml:space="preserve">
    <value>Logical and. Returns TRUE when both statements are TRUE.</value>
  </data>
  <data name="bandOperatorDescription" xml:space="preserve">
    <value>Bitwise AND</value>
  </data>
  <data name="orOperatorDescription" xml:space="preserve">
    <value>Logical or. TRUE when either or both statements are TRUE.</value>
  </data>
  <data name="borOperatorDescription" xml:space="preserve">
    <value>Bitwise OR (inclusive)</value>
  </data>
  <data name="xorOperatorDescription" xml:space="preserve">
    <value>Logical exclusive or. Returns TRUE when one of the statements is TRUE and the other is FALSE.</value>
  </data>
  <data name="bxorOperatorDescription" xml:space="preserve">
    <value>Bitwise OR (exclusive)</value>
  </data>
  <data name="joinOperatorDescription" xml:space="preserve">
    <value>Join - combine multiple strings into a single string.
-Join &lt;String[]&gt;
&lt;String[]&gt; -Join &lt;Delimiter&gt;</value>
  </data>
  <data name="shlOperatorDescription" xml:space="preserve">
    <value>Shift Left bit operator. Inserts zero in right-most bit position.</value>
  </data>
  <data name="shrOperatorDescription" xml:space="preserve">
    <value>Shift Right bit operator. Inserts zero in the left-most bit position. For signed values, sign bit is preserved.</value>
  </data>
  <data name="AssemblyKeywordDescription" xml:space="preserve">
    <value>Specifies the path to a .NET assembly to load.

using assembly &lt;.NET-assembly-path&gt;</value>
  </data>
  <data name="ModuleKeywordDescription" xml:space="preserve">
    <value>Specifies a PowerShell module to load classes from.

using module &lt;ModuleName or Path&gt;

using module &lt;ModuleSpecification hashtable&gt;</value>
  </data>
  <data name="NamespaceKeywordDescription" xml:space="preserve">
    <value>Specifies a .NET namespace to resolve types from or a namespace alias.

using namespace &lt;.NET-namespace&gt;

using namespace &lt;AliasName&gt; = &lt;.NET-namespace&gt;</value>
  </data>
  <data name="TypeKeywordDescription" xml:space="preserve">
    <value>Specifies an alias for a .NET Type.

using type &lt;AliasName&gt; = &lt;.NET-type&gt;</value>
  </data>
  <data name="beginKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is executed at the beginning of a script/function, before any process block in the pipeline has been run.

begin {}</value>
  </data>
  <data name="breakKeywordDescription" xml:space="preserve">
    <value>Exits the current loop. If a label is specified, each encompassing loop will be exited until the label is reached.
When used in a trap, it displays the trapped error and aborts execution of the script/function.

break &lt;Optional Label Name&gt;</value>
  </data>
  <data name="catchKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is executed when a terminating error is caught in a previously defined Try block.
Zero or more exceptions can be specified to catch specific errors.

catch &lt;[Optional Exception 1]&gt;, &lt;[Optional Exception 2]&gt; {}</value>
  </data>
  <data name="classKeywordDescription" xml:space="preserve">
    <value>Specifies a PowerShell class definition. A base class or one or more interfaces can optionally be specified.

class &lt;[ClassName]&gt; : &lt;[BaseClass1 or Interface1]&gt;, &lt;[Interface2]&gt; {}</value>
</data>
  <data name="cleanKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is run after a script/function is executed. This block is always run, regardless of any terminating errors.

clean {}</value>
  </data>
  <data name="continueKeywordDescription" xml:space="preserve">
    <value>Advances the loop immediately, skipping over the remaining statements. If a label is specified, each encompassing loop will be exited until the label is reached.
When used in a trap, it silences the trapped error and continues execution of the script/function.

continue &lt;Optional Label Name&gt;</value>
  </data>
  <data name="dataKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is restricted to a specified subset of the PowerShell language.
A variable and a list of supported commands can optionally be specified.

data &lt;VariableName&gt; -supportedCommand &lt;Command1&gt;, &lt;Command2&gt; {}</value>
  </data>
  <data name="doKeywordDescription" xml:space="preserve">
    <value>Defines a loop that is executed one or more times, until the specified condition is met.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

do {} while (&lt;Condition&gt;)
do {} until (&lt;Condition&gt;)
:label do {} while (&lt;Condition&gt;)
:label do {} until (&lt;Condition&gt;)</value>
  </data>
  <data name="dynamicparamKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is executed when tab completing parameters and when the command is executed to create dynamic parameters.

dynamicparam {}</value>
  </data>
  <data name="elseKeywordDescription" xml:space="preserve">
    <value>Defines a statement block that is executed if all previous if/elseif statements evaluate to false.

else {}</value>
  </data>
  <data name="elseifKeywordDescription" xml:space="preserve">
    <value>Defines a statement block that is executed if all previous if/elseif statements evaluate to false and the specified condition evaluates to true.

elseif (&lt;Condition&gt;) {}</value>
  </data>
  <data name="endKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is executed after the containing script/function has run its begin and process blocks.
The End block is executed after the Process block has finished processing all incoming pipeline input.

end {}</value>
  </data>
  <data name="enumKeywordDescription" xml:space="preserve">
    <value>Defines a PowerShell type definition for an Enum.

enum &lt;TypeName&gt; {}</value>
  </data>
  <data name="exitKeywordDescription" xml:space="preserve">
    <value>When used inside a script, stops the rest of the script from being executed.
When used interactively, exits the nested prompt (debugger, remote connection), when used at the top level it exits the shell itself.
An exit code can optionally be provided to inform the parent process about the script status.

exit &lt;ExitCode&gt;</value>
  </data>
  <data name="filterKeywordDescription" xml:space="preserve">
    <value>Defines a PowerShell function where the default block is a Process block rather than an End block.

filter &lt;FilterName&gt; {param()}
filter &lt;FilterName&gt; {param() dynamicparam {} begin {} process {} end {} clean {}}</value>
  </data>
  <data name="finallyKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is always executed after the try block, regardless of any terminating errors.

finally {}</value>
  </data>
  <data name="forKeywordDescription" xml:space="preserve">
    <value>Defines a for loop.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

for (&lt;Initializer&gt;;&lt;Condition&gt;;&lt;AdvanceAction&gt;;) {}
:label for (&lt;Initializer&gt;;&lt;Condition&gt;;&lt;AdvanceAction&gt;;) {}</value>
  </data>
  <data name="foreachKeywordDescription" xml:space="preserve">
    <value>Defines a foreach loop.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

foreach (&lt;CurrentItemVariable&gt; in &lt;Collection&gt;) {}
:label foreach (&lt;CurrentItemVariable&gt; in &lt;Collection&gt;) {}</value>
  </data>
  <data name="functionKeywordDescription" xml:space="preserve">
    <value>Defines a PowerShell function.

function &lt;FunctionName&gt; {param()}
function &lt;FunctionName&gt; {param() dynamicparam {} begin {} process {} end {} clean {}}</value>
  </data>
  <data name="hiddenKeywordDescription" xml:space="preserve">
    <value>Hides the specified class member from tab completion and Get-Member.

hidden &lt;MemberName&gt;</value>
  </data>
  <data name="ifKeywordDescription" xml:space="preserve">
    <value>Defines a statement block that is only executed if the specified condition evaluates to true.

if (&lt;Condition&gt;) {}</value>
  </data>
  <data name="inKeywordDescription" xml:space="preserve">
    <value>Required keyword in foreach loop definition.

foreach (&lt;CurrentItemVariable&gt; in &lt;Collection&gt;) {}</value>
  </data>
  <data name="paramKeywordDescription" xml:space="preserve">
    <value>Specifies the parameters for a scriptblock.

param()</value>
  </data>
  <data name="processKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is executed once for each item received from the pipeline.

process {}</value>
  </data>
  <data name="returnKeywordDescription" xml:space="preserve">
    <value>Stops execution of code in the current scriptblock and optionally returns the specified value.
In class methods that return something, all code paths need to lead to a return statement.

return &lt;Optional Value To Return&gt;</value>
  </data>
  <data name="staticKeywordDescription" xml:space="preserve">
    <value>Defines the following class member as a static member.

static &lt;MemberName&gt;</value>
  </data>
  <data name="switchKeywordDescription" xml:space="preserve">
    <value>Defines a loop that evaluates the specified conditions for each item.
Various parameters for the Switch can optionally be set.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

switch (&lt;Collection&gt;) {}
switch -OptionalParameters (&lt;Collection&gt;) {}
:label switch -OptionalParameters (&lt;Collection&gt;) {}</value>
  </data>
  <data name="throwKeywordDescription" xml:space="preserve">
    <value>Throws a terminating error, optionally with a string, ErrorRecord or Exception that describes the error.

throw &lt;Optional Expression&gt;</value>
  </data>
  <data name="trapKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is executed when an unhandled exception is thrown in the script/function.

trap {}</value>
  </data>
  <data name="tryKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is executed.
If a terminating error is thrown from the scriptblock the execution is stopped at the failing statement and the configured catch or finally scriptblocks are executed.

try {}</value>
  </data>
  <data name="untilKeywordDescription" xml:space="preserve">
    <value>Defines a condition for a Do loop, if the condition is evaluated to true, the loop exits.

do {} until (&lt;Condition&gt;)</value>
  </data>
  <data name="usingKeywordDescription" xml:space="preserve">
    <value>Defines an assembly, module, namespace, or namespace/type alias to load.

using assembly
using module
using namespace
using type</value>
  </data>
  <data name="whileKeywordDescription" xml:space="preserve">
    <value>Defines either a While loop, or a condition for a Do loop.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

while (&lt;Condition&gt;) {}
:label while (&lt;Condition&gt;) {}
do {} while (&lt;Condition&gt;)</value>
  </data>
</root>
